<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <link rel="shortcut icon" type="image/png" href="favicon.png">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>RyVibing AI</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            background: linear-gradient(135deg, #0c0c0c 0%, #1a1a2e 50%, #16213e 100%);
            color: #e4e4e7;
            margin: 0;
            padding: 0;
            min-height: 100vh;
            overflow-x: hidden;
        }

        .container {
            display: flex;
            flex-direction: column;
            height: 100vh;
            max-width: 1200px;
            margin: 0 auto;
            backdrop-filter: blur(10px);
            background: rgba(255, 255, 255, 0.02);
            border-left: 1px solid rgba(255, 255, 255, 0.1);
            border-right: 1px solid rgba(255, 255, 255, 0.1);
        }

        .header {
            padding: 1.5rem 2rem;
            background: rgba(0, 0, 0, 0.3);
            backdrop-filter: blur(20px);
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
            display: flex;
            align-items: center;
            gap: 1rem;
            position: sticky;
            top: 0;
            z-index: 100;
        }

        .header h1 {
            font-size: 1.5rem;
            font-weight: 700;
            background: linear-gradient(135deg, #8be9fd, #bd93f9, #ff79c6);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .status-indicator {
            width: 8px;
            height: 8px;
            background: #50fa7b;
            border-radius: 50%;
            animation: pulse 2s infinite;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }

        #chat-box {
            flex: 1;
            padding: 2rem;
            overflow-y: auto;
            display: flex;
            flex-direction: column;
            gap: 1.5rem;
            scroll-behavior: smooth;
            position: relative;
        }

        #chat-box::-webkit-scrollbar {
            width: 6px;
        }

        #chat-box::-webkit-scrollbar-track {
            background: rgba(255, 255, 255, 0.05);
        }

        #chat-box::-webkit-scrollbar-thumb {
            background: rgba(255, 255, 255, 0.2);
            border-radius: 3px;
        }

        .message {
            display: flex;
            gap: 1rem;
            align-items: flex-start;
            animation: slideUp 0.3s ease-out;
            opacity: 0;
            animation-fill-mode: forwards;
            width: 100%;
        }

        @keyframes slideUp {
            from {
                opacity: 0;
                transform: translateY(20px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .avatar {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.2rem;
            flex-shrink: 0;
        }

        .user-avatar {
            background: linear-gradient(135deg, #ff79c6, #bd93f9);
        }

        .bot-avatar {
            background: linear-gradient(135deg, #8be9fd, #50fa7b);
            color: #000;
        }

        .message-content {
            flex: 1;
            background: rgba(255, 255, 255, 0.05);
            padding: 1rem 1.5rem;
            border-radius: 1rem;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            position: relative;
            line-height: 1.6;
            word-wrap: break-word;
            overflow-wrap: break-word;
            min-width: 0;
        }

        .user .message-content {
            background: linear-gradient(135deg, rgba(139, 233, 253, 0.1), rgba(189, 147, 249, 0.1));
            border: 1px solid rgba(139, 233, 253, 0.2);
            max-width: 80%;
        }

        .bot .message-content {
            background: rgba(0, 0, 0, 0.3);
            border: 1px solid rgba(255, 255, 255, 0.1);
            max-width: 90%;
        }

        .user {
            flex-direction: row-reverse;
        }

        .user .message-content {
            margin-left: auto;
        }

        pre {
            background: rgba(0, 0, 0, 0.6);
            padding: 1.5rem;
            border-radius: 0.75rem;
            margin: 1rem 0;
            position: relative;
            border-left: 3px solid #8be9fd;
            overflow-x: auto;
            font-family: 'SF Mono', Monaco, 'Cascadia Code', 'Roboto Mono', Consolas, monospace;
            font-size: 0.9rem;
            line-height: 1.5;
            max-height: 400px;
            overflow-y: auto;
        }

        pre::-webkit-scrollbar {
            width: 4px;
            height: 4px;
        }

        pre::-webkit-scrollbar-track {
            background: rgba(255, 255, 255, 0.1);
        }

        pre::-webkit-scrollbar-thumb {
            background: rgba(139, 233, 253, 0.5);
            border-radius: 2px;
        }

        .code-container {
            position: relative;
            margin: 1rem 0;
        }

        .copy-btn {
            position: absolute;
            top: 1rem;
            right: 1rem;
            background: rgba(139, 233, 253, 0.1);
            color: #8be9fd;
            border: 1px solid rgba(139, 233, 253, 0.3);
            padding: 0.5rem 1rem;
            border-radius: 0.5rem;
            cursor: pointer;
            font-size: 0.8rem;
            transition: all 0.2s ease;
            backdrop-filter: blur(10px);
            z-index: 10;
        }

        .copy-btn:hover {
            background: rgba(139, 233, 253, 0.2);
            transform: translateY(-2px);
        }

        .typing-code {
            position: relative;
        }

        .typing-cursor {
            display: inline-block;
            width: 2px;
            height: 1.2em;
            background: #8be9fd;
            animation: blink 1s infinite;
            margin-left: 2px;
        }

        @keyframes blink {
            0%, 50% { opacity: 1; }
            51%, 100% { opacity: 0; }
        }

        .input-container {
            padding: 2rem;
            background: rgba(0, 0, 0, 0.3);
            backdrop-filter: blur(20px);
            border-top: 1px solid rgba(255, 255, 255, 0.1);
        }

        #chat-form {
            display: flex;
            gap: 1rem;
            align-items: flex-end;
            background: rgba(255, 255, 255, 0.05);
            padding: 1rem;
            border-radius: 1.5rem;
            border: 1px solid rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            position: relative;
        }

        .input-section {
            flex: 1;
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
        }

        #user-input {
            background: transparent;
            border: none;
            color: #e4e4e7;
            font-size: 1rem;
            padding: 0.75rem 1rem;
            outline: none;
            font-family: inherit;
            resize: none;
            min-height: 50px;
            max-height: 120px;
        }

        #user-input::placeholder {
            color: rgba(228, 228, 231, 0.5);
        }

        button {
            background: linear-gradient(135deg, #8be9fd, #50fa7b);
            color: #000;
            border: none;
            padding: 0.75rem 2rem;
            border-radius: 1.5rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            font-size: 1rem;
            display: flex;
            align-items: center;
            gap: 0.5rem;
            align-self: flex-end;
        }

        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 10px 25px rgba(139, 233, 253, 0.3);
        }

        button:active {
            transform: translateY(0);
        }

        .stop-btn {
            background: linear-gradient(135deg, #ff79c6, #ff5555);
            color: white;
            border: none;
            padding: 0.75rem 2rem;
            border-radius: 1.5rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            font-size: 1rem;
            display: flex;
            align-items: center;
            gap: 0.5rem;
            align-self: flex-end;
        }

        .stop-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 10px 25px rgba(255, 121, 198, 0.3);
        }

        button:disabled {
            opacity: 0.6;
            cursor: not-allowed;
            transform: none;
        }

        .hidden {
            display: none !important;
        }

        .typing-indicator {
            display: none;
            align-items: center;
            gap: 0.5rem;
            color: rgba(139, 233, 253, 0.8);
            font-style: italic;
            margin-bottom: 1rem;
        }

        .typing-indicator.show {
            display: flex;
        }

        .dots {
            display: flex;
            gap: 2px;
        }

        .dot {
            width: 6px;
            height: 6px;
            background: #8be9fd;
            border-radius: 50%;
            animation: bounce 1.4s infinite ease-in-out both;
        }

        .dot:nth-child(1) { animation-delay: -0.32s; }
        .dot:nth-child(2) { animation-delay: -0.16s; }

        @keyframes bounce {
            0%, 80%, 100% {
                transform: scale(0);
            }
            40% {
                transform: scale(1);
            }
        }

        .welcome-message {
            text-align: center;
            padding: 3rem 2rem;
            opacity: 0.7;
        }

        .welcome-message h2 {
            font-size: 1.5rem;
            margin-bottom: 0.5rem;
            color: #8be9fd;
        }

        .welcome-message p {
            color: rgba(228, 228, 231, 0.6);
        }

        .error-message {
            background: rgba(255, 121, 198, 0.1);
            border: 1px solid rgba(255, 121, 198, 0.3);
            color: #ff79c6;
        }

        /* Auto-scroll indicator */
        .scroll-control {
            position: absolute;
            bottom: 20px;
            right: 20px;
            background: rgba(139, 233, 253, 0.1);
            border: 1px solid rgba(139, 233, 253, 0.3);
            color: #8be9fd;
            padding: 0.5rem 1rem;
            border-radius: 1rem;
            cursor: pointer;
            font-size: 0.8rem;
            backdrop-filter: blur(10px);
            transition: all 0.3s ease;
            opacity: 0;
            pointer-events: none;
            z-index: 50;
        }

        .scroll-control.show {
            opacity: 1;
            pointer-events: all;
        }

        .scroll-control:hover {
            background: rgba(139, 233, 253, 0.2);
            transform: translateY(-2px);
        }

        /* Mobile Responsive */
        @media (max-width: 768px) {
            .container {
                height: 100vh;
                border: none;
            }

            .header {
                padding: 1rem;
            }

            .header h1 {
                font-size: 1.25rem;
            }

            #chat-box {
                padding: 1rem;
                gap: 1rem;
            }

            .message {
                gap: 0.75rem;
            }

            .avatar {
                width: 32px;
                height: 32px;
                font-size: 1rem;
            }

            .message-content {
                padding: 0.875rem 1rem;
            }

            .user .message-content {
                max-width: 85%;
            }

            .bot .message-content {
                max-width: 95%;
            }

            pre {
                padding: 1rem;
                font-size: 0.8rem;
                max-height: 300px;
            }

            .input-container {
                padding: 1rem;
            }

            #chat-form {
                padding: 0.75rem;
                gap: 0.75rem;
                flex-direction: column;
                align-items: stretch;
            }

            .input-section {
                order: 1;
            }

            button {
                order: 2;
                align-self: stretch;
                justify-content: center;
            }

            #user-input {
                font-size: 16px; /* Prevents zoom on iOS */
            }

            button {
                padding: 0.75rem 1.5rem;
                font-size: 0.9rem;
            }

            .scroll-control {
                bottom: 10px;
                right: 10px;
                padding: 0.4rem 0.8rem;
                font-size: 0.75rem;
            }
        }

        @media (max-width: 480px) {
            .welcome-message {
                padding: 2rem 1rem;
            }

            .welcome-message h2 {
                font-size: 1.25rem;
            }

            pre {
                margin: 0.75rem 0;
                max-height: 250px;
            }

            .copy-btn {
                padding: 0.4rem 0.8rem;
                font-size: 0.75rem;
            }

            .header {
                padding: 0.75rem;
            }

            #chat-box {
                padding: 0.75rem;
            }

            .input-container {
                padding: 0.75rem;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>
                ü§ñ RyVibing
            </h1>
            <div class="status-indicator"></div>
        </div>
        
        <div id="chat-box">
            <div class="welcome-message">
                <h2>Welcome to RyVibing</h2>
                <p>I'm here to help with coding, answer questions, or just chat! Ask me anything.</p>
            </div>
            <div class="scroll-control" id="scroll-control">
                üìç Auto-scroll: ON
            </div>
        </div>
        
        <div class="input-container">
            <div class="typing-indicator" id="typing-indicator">
                <span>Ry is thinking</span>
                <div class="dots">
                    <div class="dot"></div>
                    <div class="dot"></div>
                    <div class="dot"></div>
                </div>
            </div>
            
            <form id="chat-form">
                <div class="input-section">
                    <textarea id="user-input" placeholder="Type a message..." required rows="1"></textarea>
                </div>
                <button type="submit" id="send-btn">
                    <span>Send</span>
                    <span>‚Üí</span>
                </button>
                <button type="button" id="stop-btn" class="stop-btn hidden">
                    <span>Stop</span>
                    <span>‚èπ</span>
                </button>
            </form>
        </div>
    </div>

    <script>
        // Global state variables
let isTyping = false;
let currentTypingController = null;
let autoScroll = true;
let userScrolledUp = false;
let lastScrollPosition = 0;
let chatHistory = []; // Store chat history
let currentMessageId = 0; // For message tracking

// DOM elements - with error checking
const chatBox = document.getElementById("chat-box");
const scrollControl = document.getElementById("scroll-control");
const textarea = document.getElementById("user-input");
const chatForm = document.getElementById("chat-form");
const sendBtn = document.getElementById("send-btn");
const stopBtn = document.getElementById("stop-btn");
const typingIndicator = document.getElementById("typing-indicator");

// Initialize the chat interface
function initializeChat() {
    if (!chatBox || !textarea || !chatForm) {
        console.error('Required DOM elements not found. Make sure your HTML has the correct IDs.');
        return false;
    }
    
    console.log('Chat interface initialized successfully');
    setupEventListeners();
    loadChatHistory();
    return true;
}

// Setup all event listeners
function setupEventListeners() {
    // Scroll detection
    if (chatBox && scrollControl) {
        chatBox.addEventListener('scroll', handleScroll);
        scrollControl.addEventListener('click', resumeAutoScroll);
    }

    // Auto-resize textarea
    if (textarea) {
        textarea.addEventListener('input', handleTextareaResize);
        textarea.addEventListener('keydown', handleKeyDown);
        // Handle paste events
        textarea.addEventListener('paste', handlePaste);
    }

    // Form submission
    if (chatForm) {
        chatForm.addEventListener('submit', handleFormSubmit);
    }

    // Stop button
    if (stopBtn) {
        stopBtn.addEventListener('click', handleStopTyping);
    }

    // Window events
    window.addEventListener('beforeunload', saveChatHistory);
    window.addEventListener('resize', handleWindowResize);
    
    // Handle visibility changes (tab switching)
    document.addEventListener('visibilitychange', handleVisibilityChange);
}

// Scroll handling
function handleScroll() {
    const scrollTop = chatBox.scrollTop;
    const scrollHeight = chatBox.scrollHeight;
    const clientHeight = chatBox.clientHeight;
    
    // Check if user scrolled up manually
    if (scrollTop < lastScrollPosition) {
        userScrolledUp = true;
        autoScroll = false;
        updateScrollControl();
    } else if (scrollTop + clientHeight >= scrollHeight - 50) {
        // User is at or near bottom
        userScrolledUp = false;
        autoScroll = true;
        updateScrollControl();
    }
    
    lastScrollPosition = scrollTop;
}

// Update scroll control indicator
function updateScrollControl() {
    if (!scrollControl) return;
    
    if (userScrolledUp && isTyping) {
        scrollControl.textContent = 'üìç Scroll to follow';
        scrollControl.classList.add('show');
    } else {
        scrollControl.classList.remove('show');
    }
}

// Resume auto-scroll
function resumeAutoScroll() {
    autoScroll = true;
    userScrolledUp = false;
    if (chatBox) {
        chatBox.scrollTop = chatBox.scrollHeight;
    }
    if (scrollControl) {
        scrollControl.classList.remove('show');
    }
}

// Smart scroll function
function smartScroll() {
    if (autoScroll && !userScrolledUp && chatBox) {
        chatBox.scrollTop = chatBox.scrollHeight;
    }
}

// Handle textarea resize
function handleTextareaResize() {
    if (!textarea) return;
    
    textarea.style.height = 'auto';
    const newHeight = Math.min(textarea.scrollHeight, 120);
    textarea.style.height = newHeight + 'px';
}

// Handle paste events
function handlePaste(e) {
    // Allow pasting, but trigger resize after paste
    setTimeout(handleTextareaResize, 10);
}

// Handle window resize
function handleWindowResize() {
    // Recalculate chat box dimensions if needed
    smartScroll();
}

// Handle visibility change (tab switching)
function handleVisibilityChange() {
    if (!document.hidden && autoScroll) {
        // When tab becomes visible again, scroll to bottom if auto-scroll is on
        setTimeout(smartScroll, 100);
    }
}

// Handle key down events
function handleKeyDown(e) {
    if (e.key === "Enter" && !e.shiftKey) {
        e.preventDefault();
        if (chatForm) {
            chatForm.dispatchEvent(new Event('submit'));
        }
    }
}

// Stop typing functionality
function handleStopTyping() {
    if (isTyping && currentTypingController) {
        currentTypingController.abort();
        resetUIState();
        addStoppedMessage();
    }
}

// Reset UI to ready state
function resetUIState() {
    if (sendBtn) {
        sendBtn.disabled = false;
        sendBtn.classList.remove('hidden');
    }
    if (stopBtn) {
        stopBtn.classList.add('hidden');
    }
    if (typingIndicator) {
        typingIndicator.classList.remove('show');
    }
    if (scrollControl) {
        scrollControl.classList.remove('show');
    }
    
    isTyping = false;
    currentTypingController = null;
}

// Add stopped message
function addStoppedMessage() {
    if (!chatBox) return;
    
    const stoppedMessageEl = document.createElement('div');
    stoppedMessageEl.className = 'message bot';
    stoppedMessageEl.innerHTML = `
        <div class="avatar bot-avatar">ü§ñ</div>
        <div class="message-content">
            <strong>Ry:</strong><br>
            <em>Response stopped by user üõë Feel free to ask me anything else!</em>
        </div>
    `;
    chatBox.appendChild(stoppedMessageEl);
    
    // Add to chat history
    addToChatHistory('bot', 'Response stopped by user üõë Feel free to ask me anything else!', true);
    smartScroll();
}

// Main form submission handler
async function handleFormSubmit(e) {
    e.preventDefault();
    
    if (!textarea || isTyping) return;
    
    const userMessage = textarea.value.trim();
    if (!userMessage) return;

    // Remove welcome message if it exists
    removeWelcomeMessage();

    // Add user message
    addUserMessage(userMessage);
    
    // Clear input and reset textarea
    textarea.value = "";
    textarea.style.height = 'auto';
    
    // Set UI to typing state
    setTypingState(true);
    
    try {
        await sendMessageToServer(userMessage);
    } catch (error) {
        console.error('Error in form submission:', error);
        handleServerError(error);
    } finally {
        setTypingState(false);
    }
}

// Set typing state
function setTypingState(typing) {
    isTyping = typing;
    
    if (!sendBtn || !stopBtn || !typingIndicator) return;
    
    if (typing) {
        sendBtn.disabled = true;
        sendBtn.classList.add('hidden');
        stopBtn.classList.remove('hidden');
        typingIndicator.classList.add('show');
    } else {
        sendBtn.disabled = false;
        sendBtn.classList.remove('hidden');
        stopBtn.classList.add('hidden');
        typingIndicator.classList.remove('show');
        currentTypingController = null;
        if (scrollControl) {
            scrollControl.classList.remove('show');
        }
    }
    
    smartScroll();
}

// Remove welcome message
function removeWelcomeMessage() {
    if (!chatBox) return;
    
    const welcomeMessage = chatBox.querySelector('.welcome-message');
    if (welcomeMessage) {
        welcomeMessage.remove();
    }
}

// Add user message to chat
function addUserMessage(message) {
    if (!chatBox) return;
    
    const messageId = currentMessageId++;
    const userMessageEl = document.createElement('div');
    userMessageEl.className = 'message user';
    userMessageEl.setAttribute('data-message-id', messageId);
    userMessageEl.innerHTML = `
        <div class="avatar user-avatar">üë§</div>
        <div class="message-content">
            <strong>You:</strong><br>${escapeHtml(message)}
        </div>
    `;
    chatBox.appendChild(userMessageEl);
    
    // Add to chat history
    addToChatHistory('user', message);
    smartScroll();
}

// Send message to server
async function sendMessageToServer(userMessage) {
    try {
        const response = await fetch('/chat', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
            },
            body: JSON.stringify({
                message: userMessage,
                history: chatHistory.slice(-10) // Send last 10 messages for context
            })
        });

        if (!response.ok) {
            const errorText = await response.text();
            throw new Error(`Server error (${response.status}): ${errorText}`);
        }

        const data = await response.json();
        
        // Hide typing indicator
        if (typingIndicator) {
            typingIndicator.classList.remove('show');
        }
        
        // Add bot response
        await addBotMessage(data.reply || data.response || 'No response received');
        
    } catch (error) {
        throw error; // Re-throw to be handled by caller
    }
}

// Add bot message with typing animation
async function addBotMessage(message) {
    if (!chatBox) return;
    
    const messageId = currentMessageId++;
    const botMessageEl = document.createElement('div');
    botMessageEl.className = 'message bot';
    botMessageEl.setAttribute('data-message-id', messageId);
    botMessageEl.innerHTML = `
        <div class="avatar bot-avatar">ü§ñ</div>
        <div class="message-content">
            <strong>Ry:</strong><br>
            <div class="bot-response"></div>
        </div>
    `;
    chatBox.appendChild(botMessageEl);
    
    const responseContainer = botMessageEl.querySelector('.bot-response');
    currentTypingController = new AbortController();
    
    try {
        await typeMessage(responseContainer, message, currentTypingController.signal);
        
        // Add to chat history
        addToChatHistory('bot', message);
    } catch (error) {
        if (error.name !== 'AbortError') {
            console.error('Error typing message:', error);
        }
    }
}

// Handle server errors
function handleServerError(error) {
    if (!chatBox || !typingIndicator) return;
    
    typingIndicator.classList.remove('show');
    
    const errorMessageEl = document.createElement('div');
    errorMessageEl.className = 'message bot error';
    errorMessageEl.innerHTML = `
        <div class="avatar bot-avatar">ü§ñ</div>
        <div class="message-content error-message">
            <strong>Ry:</strong><br>
            Oops! Something went wrong. Please make sure the Flask server is running and try again. üîß
            <br><br><small>Error: ${escapeHtml(error.message)}</small>
        </div>
    `;
    chatBox.appendChild(errorMessageEl);
    
    // Add to chat history
    addToChatHistory('bot', `Error: ${error.message}`, true);
    smartScroll();
}

// Chat history management
function addToChatHistory(role, message, isSystem = false) {
    const historyEntry = {
        role,
        message,
        timestamp: new Date().toISOString(),
        isSystem
    };
    
    chatHistory.push(historyEntry);
    
    // Keep only last 50 messages to prevent memory issues
    if (chatHistory.length > 50) {
        chatHistory = chatHistory.slice(-50);
    }
}

// Save chat history to localStorage (if available)
function saveChatHistory() {
    try {
        if (typeof Storage !== "undefined" && chatHistory.length > 0) {
            localStorage.setItem('chatHistory', JSON.stringify(chatHistory));
        }
    } catch (error) {
        console.warn('Could not save chat history:', error);
    }
}

// Load chat history from localStorage
function loadChatHistory() {
    try {
        if (typeof Storage !== "undefined") {
            const saved = localStorage.getItem('chatHistory');
            if (saved) {
                chatHistory = JSON.parse(saved);
                console.log('Loaded chat history:', chatHistory.length, 'messages');
            }
        }
    } catch (error) {
        console.warn('Could not load chat history:', error);
        chatHistory = [];
    }
}

// Utility function to escape HTML
function escapeHtml(text) {
    const div = document.createElement('div');
    div.textContent = text;
    return div.innerHTML.replace(/\n/g, '<br>');
}

// ENHANCED MESSAGE TYPING FUNCTION
async function typeMessage(container, message, abortSignal) {
    if (!container || !message) return;
    
    console.log('Typing message:', message.substring(0, 100) + '...');
    console.log('Contains code blocks:', message.includes('```'));
    
    try {
        const parts = parseMessageParts(message);
        console.log('Parsed parts:', parts.length, 'parts found');
        
        // Render each part
        for (let i = 0; i < parts.length; i++) {
            const part = parts[i];
            
            if (abortSignal && abortSignal.aborted) {
                throw new Error('Typing aborted');
            }
            
            if (part.type === 'code') {
                console.log('Rendering code block with language:', part.language);
                await renderCodeBlock(container, part, abortSignal);
            } else {
                console.log('Rendering text part');
                await renderTextPart(container, part.content, abortSignal);
            }
        }
    } catch (error) {
        if (error.message !== 'Typing aborted') {
            console.error('Error in typeMessage:', error);
        }
        throw error;
    }
}

// IMPROVED MESSAGE PARSING
function parseMessageParts(message) {
    const parts = [];
    
    // Enhanced regex for code blocks
    const codeBlockRegex = /```(\w*)\s*\n?([\s\S]*?)\n?```/g;
    const matches = [];
    let match;
    
    // Find all code blocks
    while ((match = codeBlockRegex.exec(message)) !== null) {
        matches.push({
            start: match.index,
            end: match.index + match[0].length,
            language: match[1] || 'text',
            content: match[2].trim(),
            fullMatch: match[0]
        });
    }
    
    if (matches.length > 0) {
        console.log('Found', matches.length, 'code blocks');
        
        // Sort by position
        matches.sort((a, b) => a.start - b.start);
        
        let lastIndex = 0;
        
        for (const codeMatch of matches) {
            // Add text before code block
            if (codeMatch.start > lastIndex) {
                const textContent = message.slice(lastIndex, codeMatch.start).trim();
                if (textContent) {
                    parts.push({
                        type: 'text',
                        content: textContent
                    });
                }
            }
            
            // Add code block
            parts.push({
                type: 'code',
                language: codeMatch.language,
                content: codeMatch.content
            });
            
            lastIndex = codeMatch.end;
        }
        
        // Add remaining text
        if (lastIndex < message.length) {
            const remainingText = message.slice(lastIndex).trim();
            if (remainingText) {
                parts.push({
                    type: 'text',
                    content: remainingText
                });
            }
        }
    } else {
        // No code blocks found, treat as single text part
        console.log('No code blocks found, treating as text');
        parts.push({
            type: 'text',
            content: message
        });
    }
    
    return parts;
}

// RENDER CODE BLOCK WITH PROPER CONTAINER AND COPY BUTTON
async function renderCodeBlock(container, part, abortSignal) {
    if (!container) return;
    
    const codeContainer = document.createElement('div');
    codeContainer.className = 'code-container';
    
    // Create header with language and copy button
    const codeHeader = document.createElement('div');
    codeHeader.className = 'code-header';
    
    const languageLabel = document.createElement('span');
    languageLabel.textContent = part.language || 'code';
    languageLabel.className = 'language-label';
    
    const copyBtn = document.createElement('button');
    copyBtn.className = 'copy-btn';
    copyBtn.innerHTML = 'üìã Copy';
    copyBtn.setAttribute('aria-label', 'Copy code to clipboard');
    
    codeHeader.appendChild(languageLabel);
    codeHeader.appendChild(copyBtn);
    
    // Create pre and code elements
    const pre = document.createElement('pre');
    pre.className = 'code-pre';
    
    const code = document.createElement('code');
    code.className = `language-${part.language || 'text'}`;
    
    // Assemble the elements
    pre.appendChild(code);
    codeContainer.appendChild(codeHeader);
    codeContainer.appendChild(pre);
    container.appendChild(codeContainer);
    
    // Set up copy functionality
    copyBtn.onclick = function() {
        copyCodeToClipboard(code.textContent, copyBtn);
    };
    
    // Type the code content with animation
    await typeCodeContent(code, part.content, abortSignal);
}

// Copy code to clipboard
async function copyCodeToClipboard(codeText, button) {
    try {
        if (navigator.clipboard && window.isSecureContext) {
            await navigator.clipboard.writeText(codeText);
        } else {
            // Fallback for older browsers
            const textArea = document.createElement('textarea');
            textArea.value = codeText;
            document.body.appendChild(textArea);
            textArea.select();
            document.execCommand('copy');
            document.body.removeChild(textArea);
        }
        
        const originalText = button.innerHTML;
        button.innerHTML = "‚úÖ Copied!";
        button.classList.add('copied');
        
        setTimeout(() => {
            button.innerHTML = originalText;
            button.classList.remove('copied');
        }, 2000);
        
    } catch (err) {
        console.error('Failed to copy code:', err);
        button.innerHTML = "‚ùå Failed";
        setTimeout(() => {
            button.innerHTML = "üìã Copy";
        }, 2000);
    }
}

// RENDER TEXT PART
async function renderTextPart(container, content, abortSignal) {
    if (!container || !content) return;
    
    const textDiv = document.createElement('div');
    textDiv.className = 'text-part';
    container.appendChild(textDiv);
    
    // Handle markdown-style formatting in text
    const formattedContent = formatMarkdown(content);
    
    await typeTextContent(textDiv, formattedContent, abortSignal);
}

// Format markdown-style text
function formatMarkdown(text) {
    return text
        .replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>')  // **bold**
        .replace(/\*(.*?)\*/g, '<em>$1</em>')               // *italic*
        .replace(/`([^`\n]+)`/g, '<code class="inline-code">$1</code>') // `inline code`
        .replace(/\n/g, '<br>');                            // line breaks
}

// TYPE CODE WITH ANIMATION
async function typeCodeContent(element, code, abortSignal, speed = 1) {
    if (!element || !code) return;
    
    for (let i = 0; i < code.length; i++) {
        if (abortSignal && abortSignal.aborted) {
            throw new Error('Typing aborted');
        }
        
        const char = code[i];
        element.textContent += char;
        
        // Faster typing for code
        if (speed > 0) {
            await new Promise(resolve => setTimeout(resolve, speed));
        }
        smartScroll();
    }
}

// TYPE TEXT WITH ANIMATION
async function typeTextContent(element, text, abortSignal, speed = 2) {
    if (!element || !text) return;
    
    // Handle HTML content properly
    if (text.includes('<')) {
        // For HTML content, type the text content first, then apply formatting
        const tempDiv = document.createElement('div');
        tempDiv.innerHTML = text;
        const textContent = tempDiv.textContent || tempDiv.innerText;
        
        for (let i = 0; i < textContent.length; i++) {
            if (abortSignal && abortSignal.aborted) {
                throw new Error('Typing aborted');
            }
            
            element.textContent += textContent[i];
            if (speed > 0) {
                await new Promise(resolve => setTimeout(resolve, speed));
            }
            smartScroll();
        }
        
        // Replace with formatted HTML after typing
        setTimeout(() => {
            if (!abortSignal || !abortSignal.aborted) {
                element.innerHTML = text;
            }
        }, 100);
    } else {
        // Plain text typing
        for (let i = 0; i < text.length; i++) {
            if (abortSignal && abortSignal.aborted) {
                throw new Error('Typing aborted');
            }
            
            element.textContent += text[i];
            if (speed > 0) {
                await new Promise(resolve => setTimeout(resolve, speed));
            }
            smartScroll();
        }
    }
}

// Enhanced CSS styles
function injectStyles() {
    const style = document.createElement('style');
    style.textContent = `
        .code-container {
            margin: 10px 0;
            border-radius: 6px;
            overflow: hidden;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            border: 1px solid #e2e8f0;
        }
        
        .code-header {
            background: #2d3748 !important;
            color: #e2e8f0 !important;
            padding: 8px 12px !important;
            font-size: 12px !important;
            display: flex !important;
            justify-content: space-between !important;
            align-items: center !important;
        }
        
        .language-label {
            font-family: 'Courier New', monospace;
            font-weight: bold;
        }
        
        .copy-btn {
            background: #4a5568 !important;
            color: white !important;
            border: none !important;
            padding: 4px 8px !important;
            border-radius: 4px !important;
            cursor: pointer !important;
            font-size: 11px !important;
            transition: all 0.2s !important;
        }
        
        .copy-btn:hover {
            background: #2d3748 !important;
            transform: translateY(-1px);
        }
        
        .copy-btn.copied {
            background: #48bb78 !important;
        }
        
        .code-pre {
            background: #1a202c !important;
            color: #e2e8f0 !important;
            padding: 16px !important;
            margin: 0 !important;
            overflow-x: auto !important;
            border-top: 1px solid #2d3748 !important;
        }
        
        .code-pre code {
            font-family: 'Courier New', 'Monaco', 'Menlo', monospace !important;
            font-size: 14px !important;
            line-height: 1.5 !important;
            white-space: pre !important;
        }
        
        .inline-code {
            background: #f7fafc;
            color: #2d3748;
            padding: 2px 4px;
            border-radius: 3px;
            font-family: 'Courier New', monospace;
            font-size: 0.9em;
        }
        
        .text-part {
            margin-bottom: 8px;
            line-height: 1.6;
        }
        
        .message.error {
            border-left: 3px solid #f56565;
        }
        
        .error-message {
            background: #fed7d7;
            padding: 10px;
            border-radius: 4px;
            color: #742a2a;
        }
        
        .typing-cursor {
            background-color: #4299e1;
            animation: blink 1s infinite;
            width: 2px;
            height: 1em;
            display: inline-block;
            margin-left: 1px;
        }
        
        @keyframes blink {
            0%, 50% { opacity: 1; }
            51%, 100% { opacity: 0; }
        }
        
        /* Accessibility improvements */
        .copy-btn:focus {
            outline: 2px solid #4299e1;
            outline-offset: 2px;
        }
        
        /* Mobile responsiveness */
        @media (max-width: 768px) {
            .code-container {
                margin: 8px 0;
            }
            
            .code-pre {
                padding: 12px !important;
            }
            
            .code-pre code {
                font-size: 12px !important;
            }
        }
    `;
    document.head.appendChild(style);
}

// Initialize everything when DOM is loaded
document.addEventListener('DOMContentLoaded', function() {
    console.log('DOM loaded, initializing chat...');
    
    // Inject styles
    injectStyles();
    
    // Initialize chat interface
    if (initializeChat()) {
        console.log('Chat interface ready!');
    } else {
        console.error('Failed to initialize chat interface');
    }
});

// Export functions for external use (if needed)
if (typeof module !== 'undefined' && module.exports) {
    module.exports = {
        initializeChat,
        smartScroll,
        addToChatHistory,
        saveChatHistory,
        loadChatHistory
    };
}
    </script>
</body>
</html>
